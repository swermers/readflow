export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { createClient } from '@/utils/supabase/server';
import { checkEntitlement, format402Payload } from '@/utils/aiEntitlements';
import { generateWeeklyBriefForUser, getRollingWindowRange } from '@/utils/weeklyBrief';
import { NextRequest, NextResponse } from 'next/server';

type BriefRow = {
  overview: string;
  themes: unknown;
  created_at: string;
  auto_generated: boolean;
  week_start: string;
  week_end: string;
};

async function getExistingForWindow(
  supabase: Awaited<ReturnType<typeof createClient>>,
  userId: string,
  weekStartDate: string,
  weekEndDate: string,
) {
  const { data } = await supabase
    .from('weekly_briefs')
    .select('overview, themes, created_at, auto_generated, week_start, week_end')
    .eq('user_id', userId)
    .eq('week_start', weekStartDate)
    .eq('week_end', weekEndDate)
    .order('created_at', { ascending: false })
    .limit(1)
    .maybeSingle();

  return (data || null) as BriefRow | null;
}

export async function GET() {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const entitlement = await checkEntitlement(supabase, user.id, 'weekly_brief');
  if (!entitlement.allowed) return NextResponse.json(format402Payload(entitlement), { status: 402 });

  const { weekStartDate, weekEndDate, nextEligibleAt } = getRollingWindowRange(7, new Date());

  const { data: latest } = await supabase
    .from('weekly_briefs')
    .select('overview, themes, created_at, auto_generated, week_start, week_end')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false })
    .limit(1)
    .maybeSingle();

  const row = (latest || null) as BriefRow | null;

  return NextResponse.json({
    brief: row
      ? {
          overview: row.overview,
          themes: row.themes,
          createdAt: row.created_at,
        }
      : null,
    weekStart: row?.week_start || weekStartDate,
    weekEnd: row?.week_end || weekEndDate,
    autoGenerated: row?.auto_generated ?? true,
    generatedNow: false,
    canGenerateNew: false,
    nextEligibleAt,
    tooFewIssues: false,
  });
}

export async function POST(_request: NextRequest) {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const entitlement = await checkEntitlement(supabase, user.id, 'weekly_brief');
  if (!entitlement.allowed) return NextResponse.json(format402Payload(entitlement), { status: 402 });

  const { weekStartDate, weekEndDate, nextEligibleAt } = getRollingWindowRange(7, new Date());

  const existing = await getExistingForWindow(supabase, user.id, weekStartDate, weekEndDate);
  if (existing) {
    return NextResponse.json(
      {
        error: 'This schedule window is already generated. You can generate again when new issues arrive.',
        nextEligibleAt,
        weekStart: weekStartDate,
        weekEnd: weekEndDate,
      },
      { status: 409 },
    );
  }

  try {
    const result = await generateWeeklyBriefForUser(supabase, user.id, false, { weekStartDate, weekEndDate });
    if (result.skipped) {
      return NextResponse.json(
        { error: 'Need at least 2 issues in your current 7-day window to generate this insight.', nextEligibleAt },
        { status: 400 },
      );
    }

    const created = await getExistingForWindow(supabase, user.id, weekStartDate, weekEndDate);
    if (!created) return NextResponse.json({ error: 'Failed to generate weekly brief' }, { status: 500 });

    return NextResponse.json({
      overview: created.overview,
      themes: created.themes,
      createdAt: created.created_at,
      weekStart: weekStartDate,
      weekEnd: weekEndDate,
      nextEligibleAt,
    });
  } catch (e) {
    const message = e instanceof Error ? e.message : 'Failed to generate weekly brief';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
