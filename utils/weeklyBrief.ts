import type { SupabaseClient } from '@supabase/supabase-js';

type WeeklyBrief = {
  overview: string;
  themes: Array<{ title: string; consensus: string; sourceCount: number }>;
};

const MAX_ISSUES = 20;
const MAX_BODY_CHARS = 1200;

function stripHtml(html: string) {
  return html
    .replace(/<style[\s\S]*?<\/style>/gi, ' ')
    .replace(/<script[\s\S]*?<\/script>/gi, ' ')
    .replace(/<[^>]+>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function parseJsonFromText(text: string) {
  const direct = text.trim().replace(/^```(?:json)?\s*/i, '').replace(/```$/, '').trim();
  try {
    return JSON.parse(direct);
  } catch {
    const firstBrace = direct.indexOf('{');
    const lastBrace = direct.lastIndexOf('}');
    if (firstBrace !== -1 && lastBrace > firstBrace) {
      return JSON.parse(direct.slice(firstBrace, lastBrace + 1));
    }
    throw new Error('Could not parse JSON payload');
  }
}

function normalize(payload: unknown): WeeklyBrief | null {
  if (!payload || typeof payload !== 'object') return null;
  const obj = payload as Record<string, unknown>;
  const overview = typeof obj.overview === 'string' ? obj.overview.trim() : '';
  const themesRaw = Array.isArray(obj.themes) ? obj.themes : [];
  const themes = themesRaw
    .map((item) => {
      if (!item || typeof item !== 'object') return null;
      const t = item as Record<string, unknown>;
      const title = typeof t.title === 'string' ? t.title.trim() : '';
      const consensus = typeof t.consensus === 'string' ? t.consensus.trim() : '';
      const sourceCount = typeof t.sourceCount === 'number' ? t.sourceCount : 0;
      if (!title || !consensus) return null;
      return { title, consensus, sourceCount: Math.max(1, Math.floor(sourceCount || 1)) };
    })
    .filter(Boolean) as WeeklyBrief['themes'];
  if (!overview || themes.length === 0) return null;
  return { overview, themes: themes.slice(0, 5) };
}

async function summarizeWithAnthropic(input: string) {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  if (!apiKey) throw new Error('Anthropic key is not configured');

  const prompt = `You are building a weekly cross-newsletter brief for a busy knowledge worker.\nReturn STRICT JSON with:\n- overview: string (2-4 concise sentences)\n- themes: array of 3-5 objects, each { title: string, consensus: string, sourceCount: number }\n\nFocus on synthesis across sources, not summary per newsletter.\n\nNewsletters:\n${input}`;

  const res = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
    },
    body: JSON.stringify({
      model: process.env.ANTHROPIC_MODEL || 'claude-3-5-haiku-latest',
      max_tokens: 800,
      temperature: 0.2,
      messages: [{ role: 'user', content: prompt }],
    }),
  });

  if (!res.ok) throw new Error(`Anthropic weekly brief failed: ${res.status} ${await res.text()}`);
  const data = await res.json();
  const textBlock = Array.isArray(data?.content)
    ? data.content.find((block: any) => block?.type === 'text' && typeof block?.text === 'string')
    : null;
  const text = textBlock?.text;
  if (typeof text !== 'string') throw new Error('Anthropic response missing text');
  const normalized = normalize(parseJsonFromText(text));
  if (!normalized) throw new Error('Invalid weekly brief payload');
  return normalized;
}

function startOfWeekUTC(input = new Date()) {
  const date = new Date(Date.UTC(input.getUTCFullYear(), input.getUTCMonth(), input.getUTCDate()));
  const day = date.getUTCDay();
  const diff = day === 0 ? -6 : 1 - day;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function toISODate(date: Date) {
  return date.toISOString().slice(0, 10);
}

export function getLastCompletedWeekRange() {
  const currentWeekStart = startOfWeekUTC();
  const weekEnd = currentWeekStart;
  const weekStart = new Date(currentWeekStart);
  weekStart.setUTCDate(weekStart.getUTCDate() - 7);
  return {
    weekStartDate: toISODate(weekStart),
    weekEndDate: toISODate(weekEnd),
    nextEligibleAt: currentWeekStart.toISOString(),
  };
}


export function getRollingWindowRange(days = 7, input = new Date()) {
  const windowEnd = new Date(Date.UTC(input.getUTCFullYear(), input.getUTCMonth(), input.getUTCDate() + 1));
  const windowStart = new Date(windowEnd);
  windowStart.setUTCDate(windowStart.getUTCDate() - Math.max(1, days));
  return {
    weekStartDate: toISODate(windowStart),
    weekEndDate: toISODate(windowEnd),
    nextEligibleAt: input.toISOString(),
  };
}

type BriefGenerationOptions = {
  weekStartDate?: string;
  weekEndDate?: string;
  deliveryKey?: string;
};

export async function generateWeeklyBriefForUser(
  supabase: SupabaseClient,
  userId: string,
  autoGenerated: boolean,
  options: BriefGenerationOptions = {},
) {
  const defaultRange = getLastCompletedWeekRange();
  const weekStartDate = options.weekStartDate || defaultRange.weekStartDate;
  const weekEndDate = options.weekEndDate || defaultRange.weekEndDate;

  const existingQuery = supabase
    .from('weekly_briefs')
    .select('id')
    .eq('user_id', userId);

  const { data: existing } = await (options.deliveryKey
    ? existingQuery.eq('delivery_key', options.deliveryKey)
    : existingQuery.eq('week_start', weekStartDate))
    .maybeSingle();

  if (existing) return { skipped: true };

  const { data: issues, error } = await supabase
    .from('issues')
    .select('id, subject, body_text, body_html, senders(name)')
    .eq('user_id', userId)
    .is('deleted_at', null)
    .gte('received_at', `${weekStartDate}T00:00:00.000Z`)
    .lt('received_at', `${weekEndDate}T00:00:00.000Z`)
    .order('received_at', { ascending: false })
    .limit(MAX_ISSUES);

  if (error) throw new Error('Could not load issues for weekly brief');
  if (!issues || issues.length < 2) return { skipped: true };

  const digestInput = issues
    .map((issue) => {
      const senderName = (issue as any)?.senders?.name || 'Unknown sender';
      const text = ((issue.body_text || '').trim() || stripHtml(issue.body_html || '')).slice(0, MAX_BODY_CHARS);
      return `Sender: ${senderName}\nSubject: ${issue.subject || 'Untitled'}\nBody: ${text}`;
    })
    .join('\n\n---\n\n');

  const brief = await summarizeWithAnthropic(digestInput);

  const { error: insertError } = await supabase.from('weekly_briefs').insert({
    user_id: userId,
    overview: brief.overview,
    themes: brief.themes,
    source_issue_count: issues.length,
    week_start: weekStartDate,
    week_end: weekEndDate,
    auto_generated: autoGenerated,
    delivery_key: options.deliveryKey || null,
  });

  if (insertError) throw new Error(insertError.message);
  return { skipped: false };
}
